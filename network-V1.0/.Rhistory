library(mgm)
library(dplyr)
library(psych)
md = bfi[1:500,1:15]
str(md)
head(md)
md=na.omit(md)
str(md)
#设置随机数种子
set.seed(123)
#模拟抽样
md$sex = sample(c(1, 2), size = 468, replace = TRUE)
male_data= as.matrix(md %>% filter(sex == 1))[,-16]
female_data= as.matrix(md %>% filter(sex== 2))[,-16]
male_pre_mod = mgm(data = male_data,
type = rep('g',15),
level = rep(1,15),
lambdaSel = "CV",
ruleReg = "AND",
pbar = TRUE,
overparameterize = FALSE,
signInfo = FALSE)
male_pred_mgm = predict(object = male_pre_mod ,
data = male_data,
errorCon = c("R2"))
male_pred_mgm$errors %>% arrange(desc(R2))
Network_male = estimateNetwork(male_data, default = "EBICglasso")
plot(Network_male,layout = "spring",
pie=male_pred_mgm$errors[,2]
)
# 计算女性网络
female_pre_mod = mgm(data = female_data,
type = rep('g',15),
level = rep(1,15),
lambdaSel = "CV",
ruleReg = "AND",
pbar = TRUE,
overparameterize = FALSE,
signInfo = FALSE)
female_pred_mgm = predict(object = female_pre_mod ,
data = female_data,
errorCon = c("R2"))
female_pred_mgm$errors %>% arrange(desc(R2))
# 可视化（带有可预测值的网络图）
library(bootnet)
Network_female = estimateNetwork(female_data, default = "EBICglasso")
plot(Network_female,layout = "spring",
pie=female_pred_mgm$errors[,2]
)
nct_res=NCT(Network_male,
Network_female,
gamma=0.5,
it = 100,
test.edges=T,
test.centrality =T,
centrality = c("strength","expectedInfluence"),
p.adjust.methods = 'BH' #Bonferroni-Holm校正
)
summary(nct_res)
?msq_p5
data(msq_p5)
dim(msq_p5)
str(msq_p5)
#| label: load-packages
#| include: false
library(mgm)
mgm_mod = mgm(data = as.matrix(msq_p5),
type = rep("g", 5), #指定变量类型，均为连续变量g
level = rep(1, 5),  #连续变量的水平默认=1
lambdaSel = "EBIC", #采用EBIC估计
lambdaGam = .5,  #lasso惩罚系数，也可换用'CV'
ruleReg = "AND",
moderators = 1:5,#因调节变量未知，探索性设置
scale = TRUE #标准化,均值为0、标准差为1
)
mgm_mod$interactions$indicator
showInteraction(object = mgm_mod, int = c(2,5))
showInteraction(object = mgm_mod, int = c(3,4,5))
showInteraction(object = mgm_mod, int = c(4,5))
showInteraction(object = mgm_mod, int = c(3,5))
showInteraction(object = mgm_mod, int = c(4,5))
showInteraction(object = mgm_mod, int = c(3,5))
# 显示全部效应
FactorGraph(object = mgm_mod,
edge.labels = TRUE,
labels = colnames(msq_p5))
FactorGraph(object = mgm_mod,
labels = colnames(msq_p5),
PairwiseAsEdge = TRUE,
edge.labels = FALSE)
FactorGraph(object = mgm_mod,
labels = colnames(msq_p5),
PairwiseAsEdge = TRUE,
edge.labels = FALSE)
mgm_mod$pairwise$wadj
q = qgraph(mgm_mod$pairwise$wadj,#相关矩阵
layout = "spring",#图形布局算法
details = TRUE, #显示细节
theme='colorblind'#主题
)
library(qgraph)
q = qgraph(mgm_mod$pairwise$wadj,#相关矩阵
layout = "spring",#图形布局算法
details = TRUE, #显示细节
theme='colorblind'#主题
)
boot = bootnet(mgm_mod$pairwise$wadj,
default = "EBICglasso",
threshold = FALSE,
type="nonparametric", #选择非参数自举法
nCores = 8, #8线程，根据自己电脑配置来
statistics="all",
nBoots=500
)
res_obj = resample(object = mgm_mod,
data = as.matrix(msq_p5),
nB = 500)
res_obj = resample(object = mgm_mod,
data = as.matrix(msq_p5),
nB = 100)
plotRes(object = res_obj,
quantiles = c(0.05, .95))
plotRes(object = res_obj,
quantiles = c(0, .95),
)
res_obj$bootQuantiles
plotRes(object = res_obj,
labels = NULL,
axis.ticks = c(-.25, 0, .25, .5, .75))
#| label: load-packages
#| include: false
library(mgm)
library(qgraph)
data(msq_p5)
dim(msq_p5)
str(msq_p5)
head(msq_p5)
mgm_mod = mgm(data = as.matrix(msq_p5),
type = rep("g", 5), #指定变量类型，均为连续变量g
level = rep(1, 5),  #连续变量的水平默认=1
lambdaSel = "EBIC", #采用EBIC估计
lambdaGam = .5,  #lasso惩罚系数，也可换用'CV'
ruleReg = "AND",
moderators = 1:5,#因调节变量未知，探索性设置
scale = TRUE #标准化,均值为0、标准差为1
)
mgm_mod$interactions$indicator
showInteraction(object = mgm_mod, int = c(2,5))
showInteraction(object = mgm_mod, int = c(3,4,5))
showInteraction(object = mgm_mod, int = c(4,5))
showInteraction(object = mgm_mod, int = c(3,5))
# 显示全部效应
FactorGraph(object = mgm_mod,
edge.labels = TRUE,
labels = colnames(msq_p5))
FactorGraph(object = mgm_mod,
labels = colnames(msq_p5),
PairwiseAsEdge = TRUE,
edge.labels = FALSE)
mgm_mod$pairwise$wadj
q = qgraph(mgm_mod$pairwise$wadj,#相关矩阵
layout = "spring",#图形布局算法
details = TRUE, #显示细节
theme='colorblind'#主题
)
res_obj = resample(object = mgm_mod,
data = as.matrix(msq_p5),
nB = 100) #为了方便，仅抽样100次
plotRes(object = res_obj,
labels = NULL,
axis.ticks = c(-.25, 0, .25, .5, .75))
suppressWarnings(
plotRes(object = res_obj,
labels = NULL,
axis.ticks = c(-.25, 0, .25, .5, .75))
)
browseVignettes('mlVAR')
install.packages("huge")
#| label: load-packages
#| include: false
library('mlVAR')
library('qgraph')
library("networktools")
Model = mlVARsim(nPerson = 50,nNode = 8, nTime = 30, lag=1)
plot(Model)
print(fit1)
head(Model$Data)
Model$vars
Model$idvar
fit1 = mlVAR(data = ndefinedModel$Data,
vars = Model$vars,
idvar = Model$idvar,
lags = 1,
estimator = "lmer",
temporal = "correlated",
contemporaneous = "correlated",
nCores = 8
)
fit1 = mlVAR(data = Model$Data,
vars = Model$vars,
idvar = Model$idvar,
lags = 1,
estimator = "lmer",
temporal = "correlated",
contemporaneous = "correlated",
nCores = 8
)
summary(fit1)
summary(fit1)
summary(fit1)$Between-subject effects
summary(fit1)
# 同期网络
contemporaneous = plot(fit1, type = "temporal", title = "Estimated temporal relationships",
rule = "and",layout = "circle")
# 时序网络
temporal=plot(fit1, type = "contemporaneous", rule = "and",
title = "Estimated contemporaneous relationships", layout = "circle")
# 受试者间网络  必须取名between，否则报错
between = plot(fit1, type = "between", rule = "or",
title = "Estimated between relationships", layout = "circle")
# 计算中心性
centrality(contemporaneous)
centralityplot(contemporaneous)
centralityPlot(contemporaneous)
centralityPlot(temporal)
centralityPlot(between)
groups=c(rep('A',4),rep('B',2),rep('C',2))
b = bridge(contemporaneous, communities= groups, directed=F)
b
plot(b, include=c("Bridge Expected Influence (2-step)", "Bridge Strength", "Bridge Closeness"),
theme_bw=F, raw0 = T, signed=T)
plot(b, include=c("Bridge Expected Influence (2-step)", "Bridge Strength", "Bridge Closeness"),
theme_bw=F, raw0 = T, signed=T)
library(glmnet)
library(qgraph)
library(lavaan)
# 加载数据集
myData = read.table("ex9.36.dat",col.names = c(
"x1_T1", "x2_T1", "x3_T1", "x4_T1",
"x1_T2", "x2_T2", "x3_T2", "x4_T2",'subject'))
getwd()
# 模拟一份示例数据：10 个二分类变量（0/1）
set.seed(123)
binary_data = matrix(sample(c(0, 1), 100 * 10, replace = TRUE), nrow = n, ncol = p)
#| label: load-packages
#| include: false
# 如果没有安装的话，请先安装IsingFit包
# install.packages("IsingFit")
# 导入包
library(IsingFit)
# 模拟一份示例数据：10 个二分类变量（0/1）
set.seed(123)
binary_data = matrix(sample(c(0, 1), 100 * 10, replace = TRUE), nrow = 100, ncol = 10)
head(binary_data)
# 拟合 Ising 模型
fit = IsingFit(binary_data, family = "binomial",plot = T)
# 查看拟合结果
print(fit)
plot(fit)
#| label: load-packages
#| include: false
# 如果没有安装的话，请先安装IsingFit包：install.packages("IsingFit")
# 其他的包也是一样的，后面会用到
# 导入包
library(IsingFit)
library(qgraph)
library(mgm)
?qgraph
qgraph(fit$weiadj,layout="spring)
centrality(fit$weiadj)
data <- data.frame(
V1 = c(1, 0, 1, 0, 1,1,0,0,1),
V2 = c(0, 1, 1, 1, 0,0,1,1,1),
V3 = c(1, 0, 0, 1, 1,1,0,1,1),
V4 = c(0, 1, 1, 0, 1,0,0,1,1),
V5 = c(0, 0, 1, 1, 0,0,1,1,1),
V6 = c(0, 1, 1, 1, 1,1,1,0,0)
)
head(data)
data = data.frame(
V1 = c(1, 0, 1, 0, 1,1,0,0,1),
V2 = c(0, 1, 1, 1, 0,0,1,1,1),
V3 = c(1, 0, 0, 1, 1,1,0,1,1),
V4 = c(0, 1, 1, 0, 1,0,0,1,1),
V5 = c(0, 0, 1, 1, 0,0,1,1,1),
V6 = c(0, 1, 1, 1, 1,1,1,0,0)
)
head(data)
# 拟合 Ising 模型
fit = IsingFit(binary_data, family = "binomial",plot = T)
# 查看拟合结果
print(fit)
centrality(fit$weiadj)
#### 二分类变量 ####
library(IsingFit)
# Example binary dataset
data <- data.frame(
V1 = c(1, 0, 1, 0, 1,1,0,0,1),
V2 = c(0, 1, 1, 1, 0,0,1,1,1),
V3 = c(1, 0, 0, 1, 1,1,0,1,1),
V4 = c(0, 1, 1, 0, 1,0,0,1,1),
V5 = c(0, 0, 1, 1, 0,0,1,1,1),
V6 = c(0, 1, 1, 1, 1,1,1,0,0)
)
# Fit the Ising model
fit <- IsingFit(data, family = "binomial", plot = TRUE)
# Display the results
print(fit)
plot(fit)  #自带的函数通过qgraph包绘图
# library(qgraph)
# qgraph(fit$weiadj, layout = "spring", labels = colnames(data))
# 计算中心性
library(qgraph)
centrality(fit$weiadj)
#| label: load-packages
#| include: false
# 如果没有安装的话，请先安装IsingFit包：install.packages("IsingFit")
# 其他的包也是一样的，后面会用到
# 导入包
library(IsingFit)
library(qgraph)
library(mgm)
data = data.frame(
V1 = c(1, 0, 1, 0, 1,1,0,0,1),
V2 = c(0, 1, 1, 1, 0,0,1,1,1),
V3 = c(1, 0, 0, 1, 1,1,0,1,1),
V4 = c(0, 1, 1, 0, 1,0,0,1,1),
V5 = c(0, 0, 1, 1, 0,0,1,1,1),
V6 = c(0, 1, 1, 1, 1,1,1,0,0)
)
head(data)
# 拟合 Ising 模型
fit = IsingFit(binary_data, family = "binomial",plot = T)
# 拟合 Ising 模型
fit = IsingFit(data, family = "binomial",plot = T)
# 查看拟合结果
print(fit)
centrality(fit$weiadj)
centralityPlot(fit$weiadj,
include=c("Strength",'ExpectedInfluence', 'Closeness',"Betweenness"))
qgraph(fit$weiadj,layout = 'spring')
qgraph(fit$weiadj,layout = 'spring')
# 使用 mgm 包拟合 Ising 模型
# 二分类变量用 type = "c" 表示 (category)
fit_mgm = mgm(data = data,
type = rep("c", 6),
level = rep(2, 6),  # 2 表示二分类变量
lambdaSel = "EBIC",  # 使用 EBIC 选择正则化参数
ruleReg = "OR")  # 使用 OR 规则连接
# 使用 mgm 包拟合 Ising 模型
# 二分类变量用 type = "c" 表示 (category)
fit_mgm = mgm(data = data,
type = rep("c", 6),
level = rep(2, 6),  # 2 表示二分类变量
lambdaSel = "EBIC",  # 使用 EBIC 选择正则化参数
ruleReg = "OR")  # 使用 OR 规则连接
# 使用 mgm 包拟合 Ising 模型
# 二分类变量用 type = "c" 表示 (category)
fit_mgm = mgm(data = as.matrix(data),
type = rep("c", 6),
level = rep(2, 6),  # 2 表示二分类变量
lambdaSel = "EBIC",  # 使用 EBIC 选择正则化参数
ruleReg = "OR")  # 使用 OR 规则连接
# 查看拟合的网络结构
print(fit_mgm$pairwise$edges)  # 输出边信息
data = data.frame(
V1 = c(1, 0, 1, 0, 1,1,0,0,1,1, 0, 1, 0,1),
V2 = c(0, 1, 1, 1, 0,0,1,1,1,1, 0, 1, 0,0),
V3 = c(1, 0, 0, 1, 1,1,0,1,1,1, 0, 1, 0,1),
V4 = c(0, 1, 1, 0, 1,0,0,1,1,1, 0, 1, 0,0),
V5 = c(0, 0, 1, 1, 0,0,1,1,1,1, 0, 1, 0,1),
V6 = c(0, 1, 1, 1, 1,1,1,0,0,1, 0, 1, 0,1)
)
head(data)
# 拟合 Ising 模型
fit = IsingFit(data, family = "binomial",plot = T)
# 查看拟合结果
print(fit)
centrality(fit$weiadj)
centralityPlot(fit$weiadj,
include=c("Strength",'ExpectedInfluence', 'Closeness',"Betweenness"))
# 使用 mgm 包拟合 Ising 模型
# 二分类变量用 type = "c" 表示 (category)
fit_mgm = mgm(data = as.matrix(data),
type = rep("c", 6),
level = rep(2, 6),  # 2 表示二分类变量
lambdaSel = "EBIC",  # 使用 EBIC 选择正则化参数
ruleReg = "OR")  # 使用 OR 规则连接
# 查看拟合的网络结构
print(fit_mgm$pairwise$edges)  # 输出边信息
myData = read.table('https://www.statmodel.com/usersguide/chap7/ex7.4.dat',col.names = c("x1", "x2", "x3", "x4"))
myData = read.table('https://www.statmodel.com/usersguide/chap7/ex7.4.dat',col.names = c("x1", "x2", "x3", "x4","other"))
myData = read.table('https://www.statmodel.com/usersguide/chap7/ex7.4.dat',col.names = c("x1", "x2", "x3", "x4","other"))
data = myData[,1:4]
head(data)
# 拟合 Ising 模型
fit = IsingFit(data, family = "binomial",plot = T)
# 查看拟合结果
print(fit)
qgraph(fit$weiadj,layout = 'spring')
centrality(fit$weiadj)
centralityPlot(fit$weiadj,
include=c("Strength",'ExpectedInfluence', 'Closeness',"Betweenness"))
# 使用 mgm 包拟合 Ising 模型
# 二分类变量用 type = "c" 表示 (category)
fit_mgm = mgm(data = as.matrix(data),
type = rep("c", 6),
level = rep(2, 6),  # 2 表示二分类变量
lambdaSel = "EBIC",  # 使用 EBIC 选择正则化参数
ruleReg = "OR")  # 使用 OR 规则连接
# 使用 mgm 包拟合 Ising 模型
# 二分类变量用 type = "c" 表示 (category)
fit_mgm = mgm(data = as.matrix(data),
type = rep("c", 4),
level = rep(2, 4),  # 2 表示二分类变量
lambdaSel = "EBIC",  # 使用 EBIC 选择正则化参数
ruleReg = "OR")  # 使用 OR 规则连接
# 查看拟合的网络结构
print(fit_mgm$pairwise$edges)  # 输出边信息
# 查看拟合的网络结构
print(fit_mgm$pairwise$wadj)
centralityPlot(fit$weiadj,
include=c("Strength",'Closeness',"Betweenness"))
qgraph(fit_mgm$pairwise$wadj,
edge.color = fit_mgm$pairwise$wadj$edgecolor,
layout = "spring",
labels =  autism_data$colnames)
qgraph(fit_mgm$pairwise$wadj,
edge.color = fit_mgm$pairwise$edgecolor,
layout = "spring",
labels =  autism_data$colnames)
centrality(fit_k2$pairwise$wadj)
centrality(fit_mgm$pairwise$wadj)
centralityPlot(fit_mgm$pairwise$wadj)
centralityPlot(fit_mgm$pairwise$wadj,
include=c("Strength",'ExpectedInfluence',
'Closeness',"Betweenness"))
#| label: load-packages
#| include: false
# 如果没有安装的话，请先安装
library(mgm)
library(qgraph)
library(bootnet)
library(tidyverse)
head(autism_data$data) #数据
autism_data$type  #变量类型
fit_k2 = mgm(data = autism_data$data,
type = autism_data$type,
level = autism_data$lev,
k = 2)
fit_k2$pairwise$wadj
qgraph(fit_k2$pairwise$wadj,
edge.color = fit_k2$pairwise$edgecolor,
layout = "spring",
labels =  autism_data$colnames)
centrality(fit_k2$pairwise$wadj)
mgm_net = estimateNetwork(autism_data$data,
type = autism_data$type,
level = autism_data$lev,
default = 'mgm')
print(mgm_net)
plot(mgm_net, layout = 'spring')
centralityPlot(mgm_net)
set.seed(123)
boot_results2 = bootnet(mgm_net, nBoots = 1000,default = 'mgm',
type = "nonparametric",nCores = 14)
#  节点差异性检验  输出数值
library(tidyverse)
res2 = summary(boot_results2) %>%
ungroup %>%
filter(type == "edge") %>%
arrange(-sample)
res2
save(boot_results2, file = "mgm_boot_results2_mgm.RData")
# 节点强度两两比较，黑色表示显著
plot(boot_results2, statistics="Strength", plot="difference",order = "mean")
plot(boot_results2, labels=FALSE, order="sample")
# 边缘的差异性检验-可视化
plot(boot_results2, "edge", plot = "difference",
onlyNonZero = TRUE, order = "sample")
plot(boot_results2, "edge", plot = "difference",
onlyNonZero = TRUE, order = "sample")
plot(boot_results2, "edge", plot = "difference",
onlyNonZero = TRUE, order = "sample")
drop_res = bootnet(mgm_net, nBoots = 100, default = "mgm",
type="case", statistics="all",nCores = 12) #减轻计算负担
#计算相关稳定性系数
corStability(drop_res)
plot(drop_res, statistics="all")
#计算相关稳定性系数
corStability(drop_res)
?corStability
# 使用 mgm 包拟合 Ising 模型
# 二分类变量用 type = "c" 表示 (category)
fit_mgm = mgm(data = as.matrix(data),
type = rep("c", 4),
level = rep(2, 4),  # 2 表示二分类变量
lambdaSel = "EBIC",  # 使用 EBIC 选择正则化参数
ruleReg = "OR")  # 使用 OR 规则连接
# 查看权重领接矩阵
print(fit_mgm$pairwise$wadj)
qgraph(fit_mgm$pairwise$wadj,
edge.color = fit_mgm$pairwise$edgecolor,
layout = "spring",
labels =  autism_data$colnames)
centrality(fit_mgm$pairwise$wadj)
centralityPlot(fit_mgm$pairwise$wadj,
include=c("Strength",'ExpectedInfluence',
'Closeness',"Betweenness"))
sessionInfo()
?mlVAR
??mlVAR
