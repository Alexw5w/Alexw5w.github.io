{
  "hash": "bc7ea45175a75b8d2fe1c7190f592071",
  "result": {
    "markdown": "---\ntitle: \"交叉滞后网络\"\nformat: html\neditor: visual\n---\n\n\n网络分析是一种强大的手段，我们前面学习过的一些方法是基于横断面数据的，当数据类型从横断面数据扩展到纵向数据的时候，普通的网络分析方法就不再适用了。纵向数据可以理解为重复测量所得数据，分为面板数据、时间序列数据（N=1,N\\>1）等多种类型。前者测量次数往往不会特别多（但样本数量大），后者则会比较多（样本数量可能小）。在此背景下，交叉滞后网络分析应运而生。\n\n**交叉滞后网络分析**（Cross-Lagged Network Analysis，简称 CLNA）是结合**交叉滞后面板模型**（Cross-Lagged Panel Model, CLPM）与**网络分析**的一种方法，用于研究**多变量时间序列数据中变量之间的动态关系和相互影响**。它能够揭示多个变量在不同时点上的因果关系以及它们在时间上的相互依赖性。\n\n说起来很复杂，但其实很简单，学习交叉滞后网络分析之前**，**我们先复习下 CLPM。\n\n## 1 交叉滞后模型简介\n\n交叉滞后模型（Cross-Lagged Panel Model，简称 **CLPM**）是一种用于分析**时间序列数据中多个变量之间的因果关系**的统计方法。它主要用于分析多个时间点上同一组变量的相互影响，特别是不同变量在不同时间点之间的**滞后效应**（即某个变量在先前时间点的变化对另一个变量在后续时间点的影响）。\n\n### 1.1 CLPM的核心思想\n\n-   **自回归效应（Autoregressive Effects）**：模型中的每个变量都会在自己的时间点上预测下一个时间点的值。这意味着变量会表现出一种时间上的稳定性或持续性。比如，`X1_T2 ~ X1_T1` 表示变量 X1 在时间点 T2 的值由 X1 在时间点 T1 的值预测。\n\n-   **交叉滞后效应（Cross-Lagged Effects）**：模型中的某些变量不仅仅影响自己的未来值，还可以影响其他变量在未来的值。比如，`X2_T2 ~ X1_T1` 表示 X1 在时间点 T1 对 X2 在时间点 T2 的影响。\n\n-   **同时相关性（Concurrent Correlation）**：同一时间点上的不同变量之间可能会存在相关性，但这不是 CLPM 研究的主要焦点，CLPM 更加关注**滞后的因果关系**。\n\n### 1.2 CLPM的优点\n\n-   **因果推断**：CLPM 允许对多个时间点上的数据进行分析，帮助理解一个变量的变化是否会导致另一个变量在未来的变化。\n-   **双向分析**：CLPM 可以同时研究两个变量之间的双向影响，例如研究 A 对 B 的影响，同时也能分析 B 对 A 的影响。\n-   **控制自相关**：CLPM 控制了变量本身的时间序列自相关性，减少了混淆因果关系的可能性。\n\n### 1.3 CLPM模型示例\n\n假设我们有两个变量 `X` 和 `Y`，在两个时间点 `T1` 和 `T2` 上进行测量，CLPM 模型会如下描述：\n\n-   `X_T2 ~ X_T1`：表示 `X` 在时间点 `T1` 对时间点 `T2` 的预测。\n-   `Y_T2 ~ Y_T1`：表示 `Y` 在时间点 `T1` 对时间点 `T2` 的预测。\n-   `X_T2 ~ Y_T1`：表示 `Y` 在时间点 `T1` 对 `X` 在时间点 `T2` 的预测（交叉滞后效应）。\n-   `Y_T2 ~ X_T1`：表示 `X` 在时间点 `T1` 对 `Y` 在时间点 `T2` 的预测（交叉滞后效应）。\n\n我们可以使用 `lavaan` 包来拟合交叉滞后面板模型，当然也可以用其他软件。\n\n![](images/简单交叉滞后模型.png){fig-align=\"center\"}\n\n## 2 交叉滞后网络分析\n\n### 2.1 核心概念\n\n交叉滞后网络分析通过**网络图**直观地展示各个变量在不同时间点上的相互作用，强调变量之间的**双向影响**（即滞后影响）。该方法有助于研究不同时间点上的变量如何相互作用，并能够捕捉变量之间的**交叉滞后效应**。\n\n-   **自回归效应（Autoregressive Effects）**：描述同一变量在不同时间点之间的关系。例如，某一变量在 `T1` 时间点的状态对该变量在 `T2` 时间点的状态的影响。\n\n-   **交叉滞后效应（Cross-Lagged Effects）**：描述一个变量在 `T1` 时间点的状态如何影响另一个变量在 `T2` 时间点的状态。这可以揭示两个变量之间的滞后因果关系。\n\n-   **网络结构**：在网络图中，节点代表不同的变量，边表示这些变量之间的相互关系。边的方向表示因果顺序（如 `T1` 的一个变量影响 `T2` 的另一个变量），边的粗细或颜色可以表示影响的强度或显著性。\n\n### 2.2 主要步骤\n\n-   **数据准备**：你需要时间序列数据，其中包括多个变量在至少两个时间点的观测。例如，8 个变量在两个时间点上的测量数据，表示为 `X1_T1`, `X1_T2`, \\..., `X8_T1`, `X8_T2`。\n\n-   **拟合模型**：采用交叉滞后模型（CLPM），估计变量之间的滞后效应和自回归效应。\n\n-   **构建网络**：基于模型的参数估计，构建反映各个变量之间关系的网络图。可以将滞后效应和自回归效应表示为不同的边，边的方向和权重根据估计的系数确定。\n\n-   **网络分析与可视化**：使用网络分析工具（如 `qgraph`）来绘制网络图并分析变量之间的关系。可以通过网络图直观地观察哪些变量在时间上对其他变量有较强的影响\n\n### 3 R语言实现\n\n一些文献作者和博主将这块内容写得比较复杂，是因为他们做了很多全面或细节的工作，在这里，我只关注核心的部分。通俗点说，就是干了三件事：估计交叉滞后关系；拟合网络模型；计算中心性。其他的没有展示，如果你确实有需要，可以联系我，也可以查阅其他资料。我的运行环境见文末，可以先看看，避免因版本问题出现不兼容现象。\n\n#### 3.1 加载包和数据集\n\n加载包，glmnet是本次估计交叉滞后模型的核心工具，qgraph用于估计和可视化网络模型，没有安装的请先安装。\n\n\n\n\n\n加载数据集：本次使用的数据来自mplus，是一份在线公开的数据，我对其变量进行了微调，处理后的数据包含4个变量，每个变量共测量两次。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyData = read.table('https://www.statmodel.com/usersguide/chap9/ex9.36.dat',col.names = c(\n  \"x1_T1\", \"x2_T1\", \"x3_T1\", \"x4_T1\",  \n  \"x1_T2\", \"x2_T2\", \"x3_T2\", \"x4_T2\",'other'))\nmyData = myData[1:500,1:8]\nhead(myData)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      x1_T1    x2_T1     x3_T1     x4_T1     x1_T2     x2_T2     x3_T2\n1  0.788084 1.591209  0.511102  0.914914  1.936940 -0.107719 -0.101231\n2 -0.009034 1.469638 -0.233090 -0.876846  0.024599 -1.161630 -0.762810\n3 -1.175985 0.475876 -0.499924 -0.724097 -0.349644  1.623638  0.842133\n4  2.051786 0.676110  0.156716 -1.030892 -2.032910 -0.161885 -1.555111\n5  0.286151 1.511453  0.558715 -1.031686  2.632008  1.591209  2.891134\n6  0.609619 0.854681 -0.011676 -0.690153 -0.574647  0.516570  0.097766\n      x4_T2\n1  0.325695\n2  0.505980\n3 -0.597006\n4 -0.585915\n5  2.949251\n6 -0.409471\n```\n:::\n:::\n\n\n#### 3.2 使用glmnet估计交叉滞后模型\n\n这是关键点，先上代码，然后再解释为何可以这样做。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 指定变量个数\nk = 4\n# 构建空白矩阵，等下要用它来填补glmnet回归获得的系数\ninput = matrix(0, k, k) \n\n# 自建for循环\n# 以前一时间点测量的所有变量数据为自变量，分别对下一个时间点的变量进行正则化回归，然后提取每个回归方程的回归系数，放入我们构建好的空白矩阵input\nfor (i in 1:k){\n  set.seed(666)\n  cv_fit = cv.glmnet(as.matrix(myData[,1:k]), myData[,(k+i)], alpha = 1, standardize=T)\n  best_lambda = cv_fit$lambda.min\n  input[1:k,i] = coef(cv_fit, s = best_lambda, exact = F)[2:(k+1)]\n  print(best_lambda)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.03487359\n[1] 0.02511449\n[1] 0.004689684\n[1] 0.004742094\n```\n:::\n\n```{.r .cell-code}\ninput\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           [,1]       [,2]       [,3]       [,4]\n[1,] 0.06398311 0.25796633 0.22294470 0.18612493\n[2,] 0.31186373 0.04148868 0.08349683 0.15845230\n[3,] 0.01052138 0.15513120 0.19572806 0.08433666\n[4,] 0.00000000 0.06457500 0.04788886 0.14437457\n```\n:::\n:::\n\n\n3.3 拟合网络模型\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng1 = qgraph(input,layout = \"spring\",details = T) #也可以自己调整颜色，如color=\"gold\",edge.color='pink')\n```\n\n::: {.cell-output-display}\n![](交叉滞后网络_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n#### 3.4 去除自回归\n\n如果你不想要展示自回归，可以设置输入矩阵的对角线（自回归）为0。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 去除自回归效应\n# copy一份矩阵\nnoauotreg_input= input\n\n# 将矩阵的对角线元素设置为0\ndiag(noauotreg_input) = 0\n\n# 查看新矩阵\nnoauotreg_input\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           [,1]      [,2]       [,3]       [,4]\n[1,] 0.00000000 0.2579663 0.22294470 0.18612493\n[2,] 0.31186373 0.0000000 0.08349683 0.15845230\n[3,] 0.01052138 0.1551312 0.00000000 0.08433666\n[4,] 0.00000000 0.0645750 0.04788886 0.00000000\n```\n:::\n:::\n\n\n估计新模型：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng2 = qgraph(noauotreg_input,layout = \"spring\",details = T,color=\"gold\")\n```\n\n::: {.cell-output-display}\n![](交叉滞后网络_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n#### 3.5 计算中心性\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncentrality(g1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$OutDegree\n        1         2         3         4 \n0.6670360 0.5538129 0.2499892 0.1124639 \n\n$InDegree\n        1         2         3         4 \n0.3223851 0.4776725 0.3543304 0.4289139 \n\n$Closeness\n         1          2          3          4 \n0.07280867 0.05810737 0.03577039 0.01816202 \n\n$Betweenness\n1 2 3 4 \n1 2 0 0 \n\n$InExpectedInfluence\n        1         2         3         4 \n0.3223851 0.4776725 0.3543304 0.4289139 \n\n$OutExpectedInfluence\n        1         2         3         4 \n0.6670360 0.5538129 0.2499892 0.1124639 \n\n$ShortestPathLengths\n          1         2         3         4\n1  0.000000  3.876475  4.485417  5.372735\n2  3.206529  0.000000  7.691946  6.311048\n3  9.652685  6.446156  0.000000 11.857240\n4 18.692398 15.485869 20.881681  0.000000\n\n$ShortestPaths\n  1    2    3    4   \n1 NULL NULL NULL NULL\n2 NULL NULL NULL NULL\n3 NULL NULL NULL NULL\n4 NULL NULL NULL NULL\n```\n:::\n:::\n\n\n可视化：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncentralityPlot(g1, include=c(\"OutStrength\", \"InStrength\", \n                             \"Betweenness\",\"Closeness\"))\n```\n\n::: {.cell-output-display}\n![](交叉滞后网络_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n是不是非常简单？哈哈，毕竟错失了很多细节部分，所以会显得很简单。解释一下这个原理：\n\n前面以前说过了，交叉滞后模型的核心就是自回归和交叉滞后效应，这是通过多次回归实现的，常规思路是使用lavaan包处理（如果你用R的话），但网络分析一般是在复杂场景中进行了，变量数较多，所以通常会使用正则化的回归技术来计算这几种核心的效应值。\n\n正如我在代码注释中提到的，以前一个时间点的所有变量为x，分别以下一个时间点的变量为y（一个个来），依次建立回归模型，为了避免模型过于复杂，也为了减轻网络效应值很小的\"虚假\"的边，我们可以用L1正则化（lasso）技术来将一些比较小的系数给压缩为0，这样可以实现网络的稀疏化。\n\n然后，我们可以把得到的各回归系数存储在矩阵内，然后将其输入qgraph函数（也可以是别的）。\n\n### 4 小结与建议\n\n交叉滞后网络模型是最常见的纵向网络分析方法之一，但一般不适用于重复次数非常多的场景，比如生态瞬时数据或者密集追踪数据，这个就需要应用到一种叫做向量自回归（VAR及其变体）的技术了，这些会在后续介绍。\n\n本次仅做了一个非常简单的建模演示，如果你想要更进一步了解此类模型，建议掌握其中的原理，这样后续想继续做点什么就方便很多了。兴趣是最好的老师，高质量文献是最好的学习途径，辅助使用一些人工智能工具，往往可以事半功倍。欢迎关注我们的公众号：护理统计随笔，会不定期更新一些新的进展。\n\n最后，交叉滞后网络分析中是可以加入协变量的，就在glmnet循环部分加入，计算其系数，后面可以再剔除。\n\n**运行环境：**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.2 (2023-10-31 ucrt)\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\nRunning under: Windows 10 x64 (build 19045)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=Chinese (Simplified)_China.utf8 \n[2] LC_CTYPE=Chinese (Simplified)_China.utf8   \n[3] LC_MONETARY=Chinese (Simplified)_China.utf8\n[4] LC_NUMERIC=C                               \n[5] LC_TIME=Chinese (Simplified)_China.utf8    \n\ntime zone: Asia/Shanghai\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] qgraph_1.9.8 glmnet_4.1-8 Matrix_1.6-5\n\nloaded via a namespace (and not attached):\n [1] gtable_0.3.4      shape_1.4.6       xfun_0.41         ggplot2_3.5.0    \n [5] htmlwidgets_1.6.2 psych_2.3.9       lattice_0.21-9    quadprog_1.5-8   \n [9] vctrs_0.6.4       tools_4.3.2       generics_0.1.3    stats4_4.3.2     \n[13] parallel_4.3.2    tibble_3.2.1      fansi_1.0.5       cluster_2.1.4    \n[17] pkgconfig_2.0.3   data.table_1.15.4 checkmate_2.3.0   lifecycle_1.0.4  \n[21] farver_2.1.1      compiler_4.3.2    stringr_1.5.1     munsell_0.5.0    \n[25] mnormt_2.1.1      codetools_0.2-19  htmltools_0.5.7   glasso_1.11      \n[29] fdrtool_1.2.17    yaml_2.3.7        htmlTable_2.4.2   Formula_1.2-5    \n[33] pillar_1.9.0      Hmisc_5.1-1       iterators_1.0.14  abind_1.4-5      \n[37] rpart_4.1.21      foreach_1.5.2     nlme_3.1-163      lavaan_0.6-17    \n[41] gtools_3.9.5      tidyselect_1.2.0  digest_0.6.33     stringi_1.8.1    \n[45] dplyr_1.1.4       reshape2_1.4.4    labeling_0.4.3    splines_4.3.2    \n[49] fastmap_1.1.1     grid_4.3.2        colorspace_2.1-0  cli_3.6.2        \n[53] magrittr_2.0.3    base64enc_0.1-3   survival_3.5-7    utf8_1.2.4       \n[57] pbivnorm_0.6.0    withr_2.5.2       foreign_0.8-85    corpcor_1.6.10   \n[61] scales_1.3.0      backports_1.4.1   rmarkdown_2.25    jpeg_0.1-10      \n[65] igraph_2.0.1.1    nnet_7.3-19       gridExtra_2.3     png_0.1-8        \n[69] pbapply_1.7-2     evaluate_0.23     knitr_1.45        rlang_1.1.3      \n[73] Rcpp_1.0.11       glue_1.6.2        rstudioapi_0.16.0 jsonlite_1.8.7   \n[77] R6_2.5.1          plyr_1.8.9       \n```\n:::\n:::\n",
    "supporting": [
      "交叉滞后网络_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}