---
title: "横断面网络"
format: html
editor: visual
---

从这节开始，将分段演示如何采用R软件进行各种网络分析建模，主要内容请见右上角的目录。

为避免出现版本兼容性问题，大家可以先看看我使用的编程环境（见文末）。

### 1 导入工具包

依次导入下面六个包，第一个和第六个包是辅助包，提供了一些不错的工具；第二个是本期分析主要使用的包，第三个包提供了一些本次会用到的数据，第四个第五个是非常关键的包，包括但不限于用于计算稳定性和可预测性。

如果你还没安装，请先执行被注释掉的"install.packages"语句。

```{r}
#| label: load-packages
#| include: false

# install.packages("psychTools")
# install.packages("qgraph")
# install.packages("psych")

library("psychTools")
library('qgraph') 
library("psych")
library("bootnet")
library("mgm")
library("networktools")
```

### 2 整理数据

这里使用的是bfi人格问卷数据，这份数据是R语言内置的公开数据集。具体细节请使用?psych::bfi查询。

网络分析比较吃硬件资源，所以这次我们仅选取少量数据进行分析：500x15，即500人，15个条目。

```{r}
md = bfi[1:500,1:15] 
str(md)
head(md)
```

由于横断面网络分析不能有缺失值，所以来个简单处理：剔除有缺失值的行。

```{r}
md=na.omit(md)
str(md)
```

### 3 可视化网络模型

一般有如下几个步骤：计算相关或者偏相关矩阵；分配组（可以是症状群，可以不用）；建模并可视化。

```{r}
# 计算相关矩阵
CorMat=cor_auto(md)

# 模拟分组向量，具体请根据自己的研究来
groups=c(rep('A',5),rep('C',5),rep('E',5))

# 默认参数建模
q = qgraph(CorMat,#相关矩阵
           layout = "spring",#图形布局算法
           groups=groups, #分组信息
           details = TRUE, #显示细节
           theme='colorblind'#主题
           ) 
```

也可以不分组，看看效果。

```{r}
q1 = qgraph(CorMat,#相关矩阵
           layout = "spring",#图形布局算法
           details = TRUE, #显示细节
           theme='colorblind'#主题
           ) 

```

你觉得图形不好看，自己根据函数的帮助文档自己调整参数。

### 4 另一种建模方法

发现了吗？横断面网络模型（同期网络）的建模和可视化是非常简单的，我一般喜欢用bootnet建模，当然了，由于设置的算法不同，这两者所得网络是有区别的，择其一即可。

这里我们使用强大的bootnet包，等下我们做稳定性、准确性分析都会用到它。

建模一行代码搞定，用默认参数问题不大。

```{r}
# Estimate network
# 这里输入的是原始数据，采用EBICglasso算法计算输入矩阵
Network = estimateNetwork(md, default = "EBICglasso")

# plot network
plot(Network, layout = 'spring')
```

### 5 计算中心性指标

计算第一个网络模型的中心性指标，很轻松。

```{r}
centrality(q)
```

强度中心性报告了OutDegree与InDegree，但由于是横断面网络模型，所以它们是一样的，在有向图模型中，它们就会有差异了。

可视化中心性指标：

```{r}
centralityPlot(q, include=c("Strength",
                            'ExpectedInfluence',
                            'Closeness',
                            "Betweenness"))
```

由于没有进行标准化处理，所以有些指标的x轴刻度范围有些大。可以加一个scale参数进行控制。

```{r}
centralityPlot(q, include=c("Strength",
                            'ExpectedInfluence',
                            'Closeness',
                            "Betweenness"),
                            scale = "z-scores")

```

### 6 桥梁节点分析

在网络分析中，桥梁节点（Bridge Node）是指那些在不同社区或群组之间起到连接作用的节点。它们在网络中扮演着沟通不同群体的关键角色。桥梁节点的概念有助于识别那些在网络中可能对信息流通和群体间联系至关重要的节点。

桥梁节点（桥梁症状）的识别通常涉及到计算所谓的"桥梁中心性"（Bridge Centrality），这是一种网络分析中用来识别节点在不同社区或群体间重要性的指标，同样包括3种：桥梁强度、桥梁紧密度、桥梁中介性。桥梁中心性可以通过不同的方法来计算，这里就不展开描述了。

桥梁中心性的计算用代码很容易搞定：

```{r}
bridge(CorMat, communities= groups, directed=FALSE)
```

不但给出了3个桥梁中心性指标，还给出了预期影响（一步法、两步法都有）。可视化也是很容易的：

```{r}
#可视化桥梁症状网络
b = bridge(CorMat, communities= groups, directed=F) 
plot(b, 
     include=c("Bridge Expected Influence (2-step)", "Bridge Strength", "Bridge Closeness"), #选择要呈现的指标
     theme_bw=F, 
     raw0 = T, 
     signed=T,
     zscore=T,     #标准化
     order="value"  #排序
     ) 
```

看到一些研究者在文献中推荐用桥梁强度最大的节点作为桥梁节点，但也有文献认为应使用第80百分位数的桥梁强度/预期影响截止值选择桥梁症状。这里演示下如何用桥梁强度查询符合条件的节点。

```{r}
choose_set = b$`Bridge Strength`>quantile(b$`Bridge Strength`,
                             probs = 0.8,
                             na.rm = T)
node_name = b$`Bridge Strength`[choose_set]
node_name
```

可以看到，15个症状节点里面，有3个症状符合条件。如果你需要对其进行可视化，可以先标记出来，然后将其传入qgraph函数的groups参数。

### 7 计算可预测性

有些学者不推荐在同期/横断面网络分析中计算可预测性，但个人认为这是个不错的指标，相当于做了很多次回归分析，可以分析其他变量对节点的影响。计算方法其实很简单，这里演示下如何进行计算并对其进行可视化。

用mgm包建模：

```{r}
# mgm需要输入矩阵形式的数据，所以先做转换
mat_data = as.matrix(md)

# 建模，参数调整的细节请看帮助文档，在后续的混合建模中也会讲到
pre_mod = mgm(data = mat_data,
                   type = rep('g',15),
                   level = rep(1,15),
                   lambdaSel = "CV",
                   ruleReg = "AND", 
                   # pbar = T, 
                   overparameterize = F, 
                   signInfo = F)
```

速度是很快的，建模后通过预测函数提取可预测性值：

```{r}
pred_mgm = predict(object = pre_mod, 
                    data = mat_data,
                    errorCon = c("R2"))
pred_mgm$errors
```

有兴趣的话，你也可以对这个值进行排序。由于本节内容很多，就不展示具体操作了。

接下来，建立网络模型并绘制带有可预测性值的网络图：

```{r}
Network2 = estimateNetwork(mat_data, default = "EBICglasso")
plot(Network2,
     layout = "spring",
     pie=pred_mgm$errors[,2]
     )
```

### 8 精确性、稳定性、差异性分析

ok，接下来就该进行精确性、稳定性以及差异性分析了，由于涉及到重抽样，这个步骤需要花费一些时间，具体看你的电脑配置，演示时会尽量减少抽样次数。

我们继续用bootnet包进行分析：

```{r}
baseboot = bootnet(md, 
                  default = "EBICglasso", 
                  threshold = FALSE,
                  type="nonparametric", #选择非参数自举法
                  nCores = 8, #8线程，根据自己电脑配置来
                  statistics="all",
                  nBoots=500 
) 
```

> 注意：nBoots默认为1000，为提高速度，这里减少了次数，真实研究至少1000次以上。

绘制边缘权重精确性分析图：

```{r}
plot(baseboot, labels=FALSE, order="sample") #默认绘制的统计量是edge
```

这个置信区间（阴影部分）还是有些宽的。绘制边缘权重差异性分析图：

```{r}
plot(baseboot,
     statistics='edge',
     plot = "difference", 
     onlyNonZero = T, 
     order = "sample")
```

你是否会困惑：怎么看这幅图？答案是看黑格子数，黑色方格表示的是有两条边之间有显著差异，由于上面已经写了排序的代码，所以直接看y轴就可以了，越高的位置表示此edge与越多的其余edge有显著差异。这个例子，C4-C5与和E1-E2的边缘权重与其他有显著差别。

同样，可以检验不同节点中心性之间的差异：

```{r}
plot(baseboot, statistics="Strength", plot="difference",order = "mean")
```

解释方法同前。上面是图形展示，当然是可以直接计算数值的，这里就不展示了，有需求的话，可以通过护理统计随笔公众号或者微信留言，会考虑通过更新的方式进行补充。

中心性指标的稳定性也是可以通过bootnet进行计算：

```{r}
# 采用剔除案例法
caseboot = bootnet(md, 
                   nBoots = 500, 
                   nCores = 12, 
                   threshold = FALSE, 
                   default = "EBICglasso", 
                   type="case", 
                   statistics="all",
                   verbose = F)
```

> 注意：nBoots默认为1000，为提高速度，这里减少了次数，真实研究至少1000次以上。

计算相关稳定性系数CS：

```{r}
corStability(caseboot) 
```

绘图:

```{r}
plot(caseboot, statistics="all")
```

选几个指标来绘图：

```{r}
plot(caseboot, statistics = c("Strength","Closeness",
                             "expectedInfluence"))
```

**运行环境：**

```{r}
sessionInfo()
```
